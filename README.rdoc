= DataGraph

Simplified eager loading for ActiveRecord

== Description

The eager loading mechanism of ActiveRecord has {several
cases}[http://gist.github.com/492409] where these two are not equivalent as
you might expect:

  Model.find(:first, :include => :assoc).assoc
  Model.find(:first).assoc

It's often tricky, although not impossible, to make associations that work
correctly with include. DataGraph makes eager loading easier by providing a
straightforward way to declare, load, and serialize a specific set of
associated data.

== Usage

DataGraph selects data using a syntax based on the ActiveRecord {serialization
inputs}[https://github.com/rails/rails/blob/v2.3.8/activerecord/lib/active_record/serializers/xml_serializer.rb#L3]
(specifically :only, :except, :include). Only the fields specified in the
options are loaded from the database.

  require 'data_graph'
  graph = Model.data_graph(
    :only => [:a, :b],
    :include => {
      :assoc => {
        :only => [:x, :y]
  }})
  
  data = graph.find(:first)
  data.a                         # => 'A'
  data.b                         # => 'B'
  data.c                         # !> ActiveRecord::MissingAttributeError
  data.assoc.x                   # => 'X'
  data.assoc.y                   # => 'Y'
  data.assoc.z                   # !> ActiveRecord::MissingAttributeError

Any number of associations may be eagerly loaded this way, and to any nesting
depth.  DataGraph always uses a 'one query per-association' strategy and never
reverts to left outer joins the way include {sometimes
will}[https://github.com/rails/rails/blob/v2.3.8/activerecord/lib/active_record/association_preload.rb#L8].

Once you have some data, the graph options can be re-used for serialization.

  data.to_json(graph.options)
  # => '{"a":"A","b":"B","assoc":{"x":"X","y":"Y"}}'

Serialization options that are not relevant to DataGraph (such as :methods)
are ignored during the query, and likewise the extra options used by DataGraph
(:always, :aliases, :subsets) are ignored by the serializer. These extra
options are a little funky and mostly irrelevant unless using DataGraph
subsets.

== Subsets (a special use case)

DataGraph was originally designed to limit access to models via a generic API.
At one URL users could access one subset of fields, at another URL users could
access a different subset of fields. Subsets are a special functionality that
allow DataGraph define these subsets and to ensure that only some fields are
accessible.

The full set of accessible fields can be summarized as call paths, ie the
chain of method calls that get to some bit of data. These are the call paths
that return data from the example graph.

  graph.paths                    # => ['a', 'b', 'assoc.x', 'assoc.y']

Specifying a subset of these paths produces a subset graph.

  subset = graph.only('a', 'assoc.x')
  subset_data = subset.find(:first)
  
  subset_data.a                  # => 'A'
  subset_data.assoc.x            # => 'X'
  subset_data.assoc.y            # !> ActiveRecord::MissingAttributeError

Just like the full graph, the subset prevents access to unspecified fields.
Moreover, a graph can't make a subset that accesses an already-inaccesible
field (ex 'c').

  subset = graph.only('a', 'c', 'assoc.x', 'assoc.z')
  subset.paths                   # => ['a', 'assoc.x']

With these features, the generic API would consist of a 'master' graph
detailing the full set of fields accessible from an endpoint, and a way for
users to specify what fields they desire. The controller makes a subset based
on the request, queries on that subset, and serializes the result.

Basically:

  # http://example.com/things/1234?select[]=a&?select[]=assoc.x
  get '/things/:id' do
    subset = master.only('a', 'assoc.x')
    subset.find(1234).to_json(subset.options)
  end

To this end of making this API feasible, there are three DataGraph options that have no ActiveRecord analogue: :always, :aliases, and :subsets.

As with ActiveRecord the :method option can be used to make methods available
in a subset. In cases where a method needs certain columns to be present (for
instance a 'city_state' method that makes a string from columns 'city' and
'state'), DataGraph provides the :always option. These columns will always be
queried from the database, and therefore available to a method, but only
directly accessible as specified by :only or :except.

Aliases are a convenience to specify many paths at once. By default '*'
represents all available columns, and an 'assoc.*' is made available to
represent all the columns on an association.

  graph.only('*').paths          # => ['a', 'b']
  graph.except('assoc.*').paths  # => ['a', 'b']

The :aliases option allows other aliases to be defined on a graph. Finally,
the :subsets option allows graphs to predefine common subsets.

== Installation

DataGraph is available as a {gem}[http://rubygems.org/gems/data_graph]

  gem install data_graph

== Development

Clone the repo, bundle install, and run the tests:

  bundle install
  rake test

Please report any issues {here}[https://github.com/pinnacol/data_graph/issues].

== Info

Developer:: {Simon Chiang}[http://github.com/thinkerbot]
License:: {MIT-Style}[link:files/License_txt.html]